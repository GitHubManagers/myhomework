<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8"/>
  <title>JavaScript</title>
  <link rel="stylesheet" href="css/bootstrap.css"/>
  <link rel="stylesheet" href="css/mweb.css"/>
</head>
<body>
<div class="container">
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">1、简要描述JavaScript的数据类型？</h3>
    </div>
    <div class="panel-body">
      <p>JavaScript的数据类型可以分为原始类型和对象类型。</p>

      <p>
        原始类型包括string、number和boolean三种。其中，字符串是使用一对单引号或者一对双引号括起来的任意文本；而数值类型都采用64位浮点格式存储，不区分整数和小说；布尔(逻辑)只能有两个值：true或false。</p>

      <p>复杂类型指其它对象，如Array、Date、Object等。</p>

      <p>除此之外，JavaScript中还有两个特殊的原始值：null(空)和undefined(未定义)，它们代表了各自特殊类型的唯一成员。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">2、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列表达式的计算结果：</p>
      <img src="img/js1.png" alt=""/>

      <h3>参考答案：</h3>

      <p>上述代码的结果分别为：</p>

      <p class="shadow">
        1 <br/>
        1 <br/>
        true
      </p>

      <p>将对象赋值给变量，仅仅是赋值的引用，对象本身并没有赋值一次，因此，变量a和b指向同一个数组。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">3、简要描述null和undefined的区别？</h3>
    </div>
    <div class="panel-body">
      <p>null是JavaScript的关键字，用于描述“空值”，对其执行typeof操作，返回“object”，即为一个特殊的对象值，可以表示数字、字符串和对象是“无值”的。</p>

      <p>
        undefined是预定义的全局变量，其值为“未定义”，它是变量的一种取值，表示变量没有初始化。当查询对象属性、数组元素的值时，如果返回undefined则表示属性或者元素不存在；如果函数没有任何返回值，也返回undefined。</p>

      <p>需要注意的是，虽然null和undefined是不同的，但是因为都表示“值的空缺”，两者可以互换。因此，使用“==”认为二者是相等的，需要使用“===”来区分它们。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">4、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列表达式的计算结果：</p>
      <img src="img/js2.png" alt=""/>

      <h3>参考答案</h3>

      <p>上述代码的结果分别为：</p>

      <p class="shadow">
        10objects //转换为字符串 <br/>
        28 //转换为字符 <br/>
        NaN //无法转换为数值进行计算，因此返回NaN <br/>
        1[object Object] //返回对象的toString()结果，按照字符串相加<br/>
        2 //bool类型转换为数值类型 <br/>
        2 //null转换为数值0
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">5、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>
      <img src="img/js3.png" alt=""/>

      <h3>参考答案</h3>

      <p>上述代码的结果分别为：</p>

      <p class="shadow">
        8 <br/>
        2 <br/>
        2 <br/>
        5 <br/>
        console.log(n[0].x);此行代码错误，无法输出有效信息，会输出Error信息。
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">6、阅读如下代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js4.png" alt=""/>

      <p>上述代码运行后，变量x、y和z的值分别为多少？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        变量x的值为11 <br/>
        变量y的值为20 <br/>
        变量z的值为10 <br/>
      </p>

      <p>这是因为,运行第三行代码时，只执行？后的第一个语句，因此，y的值不发生变化，仍为20；并返回x的值赋值给变量z，因此z的值为10，然后将x的值增加1，变为11。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">7、什么是“逻辑短路”？</h3>
    </div>
    <div class="panel-body">
      <h3>参考答案：</h3>

      <p>逻辑短路时对于逻辑运算而言，是指，仅计算逻辑表达式中的一部分便能确定结果，而不对整个表达式进行计算的现象。</p>

      <p>对于“&&”运算符，当第一个操作数为false时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是false；</p>

      <p>对于“||”运算符，当第一个操作数为true时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是true。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">8、阅读如下代码</h3>
    </div>
    <div class="panel-body">
      <img src="img/js5.png" alt=""/>

      <p>上述代码运行后，将产生有效输出，还是代码错误？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行，会输出2，而不会发生错误。
      </p>

      <p>
        这是因为，if条件中的逻辑表达式的第一个条件(empAge>20)不满足条件，会返回false，此时，将发生“逻辑短路”，而不会继续判断下一个条件。因此，即使下一个条件中的变量empName没有赋值，此时如果计算empName.length将发生错误；但是，因为发生了“逻辑短路”，不会计算此表达式，因此不会发生错误。</p>

      <p>既然if条件中的逻辑表达式返回false，则运行else语句：输出2.</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">9、解释一下JavaScript中的局部变量和全局变量的区别？</h3>
    </div>
    <div class="panel-body">
      <p>全局变量拥有全局作用域，在JavaScript代码的任何地方都可以访问；在函数内声明的变量只在函数体内有定义，即为局部变量，其作用域是局部性的。</p>

      <p>需要注意的是，在函数体内声明局部变量时，如果不使用var关键字 ，则将声明为全局变量。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">10、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>
      <img src="img/js6.png" alt=""/>

      <h3>参考答案：</h3>

      <p class="shadow">上述代码的输出结果为local</p>

      <p>这是因为，在函数test()体内，局部变量的优先级高于同名的全局变量。因此，如果在函数体内声明的局部变量和全局变量重名，者以局部变量优先。因此，调用函数test()时，返回的是局部变量x，其值为local。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">11、什么是JavaScript中的函数作用域？</h3>
    </div>
    <div class="panel-body">
      <p>
        JavaScript中的函数作用域是指：变量在声明它的函数体以及这个函数体嵌套的任意函数体内都是有定义的。这意味着，在函数体内声明的所有变量在整个函数体内始终是可见的，这种特性也被称为“声明提前”，即，函数内声明的所有变量(不涉及到赋值)都被提前至函数的顶部声明。</p>

      <p>比如，查看如下代码：</p>
      <img src="img/js7.png" alt=""/>

      <h3>参考答案：</h3>

      <p class="shadow">上述代码运行，将先输出undefined，再输出10</p>

      <p>这是因为，虽然变量x在第二行声明并赋值，但其有效范围为整个函数体，因此，第一行代码输出时，表示变量x已经声明但是没有赋值，因此输出undefined；第三行代码运行时，因为变量x已经赋值为10了，则输出10.</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">12、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>
      <img src="img/js8.png" alt=""/>

      <h3>参考答案：</h3>

      <p class="shadow">上述代码中，输出sum的值为45；输出i的值为10.</p>

      <p>这是因为，在函数test()体内，循环计算完毕后，变量sum的值为从0累加到10的和，即为45；变量i虽然是在for循环中声明，但是在整个函数体内都有效(函数作用域)，因此，循环完毕后，变量i的值为10。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">13、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>
      <img src="img/js9.png" alt=""/>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码中，先输出undefined，再输出local。
      </p>

      <p>
        函数test()体内声明了与全局变量同名的局部变量x，则将覆盖全局变量，即局部变量优先。因此，第一次输出变量x时，为输出局部变量x，此时变量x只有声明而没有赋值，因此输出undefined；第二次输出x时，局部变量已经赋值，因此输出字符串local。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">14、简述arguments对象的作用</h3>
    </div>
    <div class="panel-body">
      <p>
        在函数代码中，使用特殊对象arguments可以访问函数的参数。即，开发者在定义函数时，无需明确的为方法声明参数，也可以在方法体中使用arguments来访问参数。这是因为，arguments是一种特殊对象，在函数代码中，表示函数的参数数组。</p>

      <p>
        正是因为arguments表示参数组成的数组，因此，首先可以使用arguments.length检测函数的参数个数，其次，可以通过下标(arguments[index])来访问某个参数。这样，可以用arguments对象判断传递给函数的参数个数并获取参数，适用于函数参数无法确定个数的情况下。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">15、简要描述JavaScript中定义函数的几种方式。</h3>
    </div>
    <div class="panel-body">
      <p>JavaScript中，有三种定义函数的方式：</p>

      <p>1、函数语句：即适用function关键字显式定义函数。如：</p>

      <p>
        function fun(x){ <br/>
        return x+1; <br/>
        }
      </p>

      <p>2、函数定义表达式：也称为“函数直接量”，形如：</p>

      <p>var fun = function(x){ return x+1; };</p>

      <p>3、适用Function()构造函数定义，形如：</p>

      <p>var fun = new Function("x","return x+1;");</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">16、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>

      <p>
        var fun = function(x){ return x*x;};
        console.log(fun);
        console.log(fun(10));
      </p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行时，先输出var fun = function(x){ return x*x;};再输出100。
      </p>

      <p>这是因为，变量fun代表一个函数对象，因此直接输出变量时，将输出函数体对应的字体文本；fun(10)表示调用变量fun所对应的函数，返回100并输出。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">17、阅读如下代码</h3>
    </div>
    <div class="panel-body">
      <img src="img/js10.png" alt=""/>

      <p>上述代码运行后，输出结果为？</p>

      <h3>参考答案:</h3>

      <p class="shadow">
        上述代码运行，会先输出:function f(){console.log("function")}; <br/>
        然后输出：function; <br/>
        再输出：hello; <br/>
        最后会输出异常信息：string is not a function。
      </p>

      <p>
        这是因为，定义函数时，函数名称作为一个全局变量，该变量指向函数对象。因此，执行函数test中的第一行代码时，将输出变量f所对应的函数对象，即输出函数体中代码的字符串形式；然后执行f()表示调用方法f,则输出字符串“function”；执行代码f="hello",意味着将变量f的值改为字符串，因此再输出变量f时，将输出字符串"Hello";而如果试图再执行f(),会引发错误。这是因为，此时，变量f不再是一个函数对象，而是一个普通的字符串。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">18、列举几个JavaScript中常用的全局函数，并描述其作用。</h3>
    </div>
    <div class="panel-body">
      <p>JavaScript中常用的全局函数及其作用如下：</p>
      <ul>
        <li>1、parseInt:解析一个字符串并返回一个整数；</li>
        <li>2、parseFloat：检查某个值是否是数字，返回true或者false；</li>
        <li>3、encodeURI:把字符串作为URI进行编码；</li>
        <li>4、decodeURI:对encodeURI()函数编码过的URI进行解码；</li>
        <li>5、isNaN:检查某个值是否是数字，返回true或者false；</li>
        <li>6、eval:计算某个字符串，以得到结果，或者用于执行其中的JavaScript代码。</li>
      </ul>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">19、阅读如下代码</h3>
    </div>
    <div class="panel-body">
      <img src="img/js11.png" alt=""/>

      <p>上述代码运行后，页面的输出结果为？</p>

      <h3>参考答案：</h3>

      <p class="shadow">上述代码运行，会在页面输出：1&nbsp;20&nbsp;21&nbsp;301&nbsp;302&nbsp;310&nbsp;311</p>

      <p>函数printArray使用了递归方式，逐一输出数组中的每个成员，中间一空格隔开</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">20、编写函数，实现冒泡排序</h3>
    </div>
    <div class="panel-body">
      <h3>参考答案：</h3>

      <p>使用JavaScript编写的冒泡排序函数如下所示：</p>
      <img src="img/js12.png" alt=""/>

      <p>测试函数bubbleSort，代码如下：</p>

      <p>
        var arr = [12,4,9,21,43,3]; <br/>
        bubbleSort(arr); <br/>
        console.log(arr);
      </p>

      <p class="shadow">
        上述代码运行时，将输出排序后的结果：[3,4,9,12,21,43]
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">21、编写函数，实现插入排序</h3>
    </div>
    <div class="panel-body">
      <h3>参考答案：</h3>

      <p>插入排序是指，先假定将n个元素的数列分为有序和无序两个部分；然后将无序数列的第一个元素与有序数列的元素从后面往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。过程如下图所示：</p>
      <img src="img/js13.png" alt=""/>

      <p>使用JavaScript编写的插入排序函数如下所示：</p>
      <img src="img/js14.png" alt=""/>

      <p>测试函数bubbleSort，代码如下：</p>

      <p>
        var arr = [12,4,9,21,43,3]; <br/>
        bubbleSort(arr); <br/>
        console.log(arr);
      </p>

      <p class="shadow">
        上述代码运行时，将输出排序后的结果：[3,4,9,12,21,43]
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">22、编写函数，实现对身份证号码最后一位的验证</h3>
    </div>
    <div class="panel-body">
      <p>二代身份证号码为18为，其中最后一位(第18为)的计算方法为：</p>
      <ul>
        <li>1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七为的系数分别为：7-9-10-5-8-4-2-1-6-3-7-9-10-5-8-4-2</li>
        <li>2、将这17位数和系数相乘的结果相加</li>
        <li>3、用加出来的和除以11，看余数是多少？</li>
        <li>4、余数只可能有0-1-2-3-4-5-6-7-8-9-10这11个数字。每个数字所对应的最后一位身份证的号码为1-0-X-9-8-7-6-5-4-3-2</li>
      </ul>
      <p>
        例如：某男性的身份证号码是34052419800101001X。验证其最后一位是否正确时，首先需要得出前17位的乘积和是189，然后用189除以11得出的结果是17+2/11，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的数字是X。所以，可以判断此身份证号码的最后一位是合格的。</p>

      <h3>参考答案：</h3>

      <p>编写验证方法如下：</p>
      <img src="img/js15.png" alt=""/>

      <p>测试该方法：</p>

      <p>
        var id = "34052419800101001X";
        console.log(verifyCode(id));
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">23、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>
      <img src="img/js16.png" alt=""/>

      <h3>参考答案：</h3>

      <p class="shadow">上述代码的输出结果为[40,50]</p>

      <p>数组的方法push()表示入栈，即在栈顶(数组尾端)添加指定的元素；方法pop()表示出栈，删除并返回栈顶(数组尾端)的元素。</p>

      <p>代码中，第一次入栈为数字30；第二次入栈为数组[40,50],且该数组排在栈顶。因此，调用方法pop()时，将删除并返回栈顶元素[40,50],这是一个数组，因此输出结果为[40,50]</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">24、什么是栈？在JavaScript中，如何模拟栈操作？</h3>
    </div>
    <div class="panel-body">
      <p>
        栈(stack)是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对的把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。栈的操作如下图所示：</p>
      <img src="img/js17.png" alt=""/>

      <p>
        在JavaScript中，可以使用数组及其相关操作模拟栈操作。首先，使用数组存储一列元素，然后使用数组的push()方法在数组的尾部添加指定的元素，类似于在栈顶添加元素，即顶部入；然后使用数组的pop()删除并返回数组尾部的元素，类似于顶部出栈，即后入的元素先出。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">25、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>

      <p>
        var arr1 =[10,20,30,40];<br/>
        arr1.push(59);<br/>
        arr1.shift(); <br/>
        console.log(arr1);
      </p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码的输出结果为[20,30,40,50]
      </p>

      <p>
        数组的方法push()表示入栈，即在栈顶(数组尾端)添加指定的元素，因此，数字50将作为数组的最后一个元素；方法shift()表示删除并返回栈底(数组头部)的元素，因此，将从数组删除数值10。此时，输出数组剩余的4个数值，即[20,30,40,50]</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">26、什么是正则表达式？JavaScript中，如果应用正则表达式？</h3>
    </div>
    <div class="panel-body">
      <p>正则表达式(Regular Expression)本身就是一个字符串，有一些普通字符和特殊字符组成的，用以描述一种特定的字符规则的表达式。</p>

      <p>正则表达式常用于在一段文本中搜索、匹配或替换特定形式的文本。如：词语出现频率统计、验证字符串是否符合邮箱格式、屏蔽一篇帖子的限制性词语等。许多程序设计语言都支持利用正则表达式进行字符串操作。</p>

      <p>在JavaScript中，正则表达式的应用分为两种：</p>
      <ul>
        <li>1、结合String对象的replace、search和match方法，实现对字符串的替换、查找和匹配；</li>
        <li>2、定义正则表达式对象，实现对字符串的复杂匹配操作。</li>
      </ul>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">27、读代码，写结果</h3>
    </div>
    <div class="panel-body">
      <p>写出下列代码的输出结果：</p>
      <img src="img/js18.png" alt=""/>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码的输出结果为3
      </p>

      <p>String的search(regexp)方法，用于返回第一次出现匹配指定正则表达式的下标，若没有匹配则返回-1.</p>

      <p>试题中，正则表达式\bdo\b表示匹配完整的单词do，且不区分大小写。而变量data中，第一次出现单词do(不区分大小写)的位置为16。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">28、阅读如下代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js19.png" alt=""/>

      <p>上述代码运行后，输出的结果为：</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行后，会先输出 catch block;再输出finally block。
      </p>

      <p>这是因为，执行代码 num = Number(num);时，因为传入的参数值为字符串“10x”,无法转换为number类型，这产生错误，运行到catch语句块中，输出“catch
        bloc”；而finally块始终会运行，因此继续输出“finally block”。程序发生异常后，将退出，因此不再执行其它语句。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">29、简要描述JavaScript中的匿名函数</h3>
    </div>
    <div class="panel-body">
      <p>匿名函数是指在定义时没有指定名字的函数，且定义后往往直接调用。如：</p>

      <p>
        function(num1,num2){ <br/>
        console.log(num1+num2); <br/>
        }
      </p>

      <p>这种方式所定义移动匿名函数，往往需要直接调用，如：</p>

      <p>
        (function(num1,num2){ <br/>
        console.log(num1+num2); <br/>
        })(10,20);
      </p>

      <p>匿名函数常用于定义不需要重复使用的函数，用完即释放。另外，对于直接调用的匿名函数而言，可以看成是一个临时的命名空间，其区域内定义的所有变量，不会污染到全局命名空间。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">30、简要描述JavaScript中的作用域链</h3>
    </div>
    <div class="panel-body">
      <p>任何一段JavaScript代码都对应一个作用域链，作用域链中存放一些列对象，代码中声明的变量将作为对象的属性存放。</p>

      <p>在JavaScript的顶层代码中，作用域链由一个全局对象组成；当定义一个函数时，它保存一个作用域链，作用域链上有两个对象，一个是函数对象，一个是全局对象。</p>

      <p>每当一个函数被调用时，会创建一个活动对象(也叫上下文对象)，函数中的局部变量将作为该对象的属性存放。</p>

      <p>
        当需要使用一个变量时，将从作用域链中逐个查找对象的属性。比如：要使用变量a,将先查找作用域中的第一个对象是否有属性a，如果有就使用；如果没有就查找作用域链中下一个对象的属性，以此类推。如果作用域链上没有任何一个对象含有属性x，则认为这段代码的作用域链上下文不存在x，将抛出引用错误异常。</p>

      <p>当函数调用完成后，如果没有其它引用指向为此次调用所创建的上下文对象，该对象将被回收。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">31、阅读如下代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js20.png" alt=""/>

      <p>上述代码运行后，输出结果为？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行，会输出200
      </p>

      <p>上述代码意味着，先执行f()，得到该函数内嵌套的一个函数对象g，然后调用这个嵌套的函数。</p>

      <p>定义函数f时，它保存一个作用域链，作用域链上有两个对象，一个是函数对象，一个是全局对象，此时，全局变量a是全局对象的属性，和函数对象f无关。</p>

      <p>执行函数f时，会创建一个活动对象，其中保存变量a作为函数f的属性而存在。而函数g嵌套定义在函数f里，对其访问变量a时，它没有变量a，则继续往下查找函数f的属性a并返回。因此，输出结果为200。</p>

      <p>这种函数将变量包裹起来，外部代码可以通过内嵌函数g来访问函数f内的局部变量的方式，也称为闭包。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">32、简要描述里对闭包的理解</h3>
    </div>
    <div class="panel-body">
      <p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。这意味着函数变量可以隐藏于作用域链之内，看起来好像是函数将变量包裹了起来。这种方式常用于共享函数内的私有变量。</p>

      <p>闭包有如下应用特征：</p>
      <ul>
        <li>1、局部变量：在函数中定义有共享意义(如：缓存、计数器等)的局部变量(注：定义成全局变量会对外造成污染);</li>
        <li>2、内嵌函数：在函数中声明有内嵌函数，内嵌函数对函数中的局部变量进行访问；</li>
        <li>3、外部使用：函数向外返回此内嵌函数，外部可以通过此内嵌函数持有并访问声明在函数中的局部变量，而此变量在外部是通过其它途径无法访问的。</li>
      </ul>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">33、阅读如下代码</h3>
    </div>
    <div class="panel-body">
      <img src="img/js21.png" alt=""/>

      <p>上述代码运行后的输出为？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行后，分别输出数字1、2、3
      </p>

      <p>首先从应用上分析，这是一个闭包的典型应用：模拟计数器。调用一次函数counter，则得到一个计数器，即代码中的变量c1，用于统计被调用的次数；每运行一次计数器c1，则访问次数加1，因此分别输出数字1、2、3</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">34、阅读如下代码</h3>
    </div>
    <div class="panel-body">
      <p>
        for(var i=0;i<3;i++){ <br/>
        setTimeout(function(){ <br/>
        alert(i); <br/>
        },3000); <br/>
        }
      </p>

      <p>上述代码希望实现：3s后弹出三次警告对话框，对话框中显示的数字分别为0、1、2。</p>

      <p>问：上述代码能否实现所需要的效果？如果不能，应该如何实现？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码不能实现所需要的效果。会在3s后弹出三次警告对话框，对话框中的数字均为3。
      </p>

      <p>这是因为，循环结束后，变量i的值为3；当3s后运行循环中内嵌的函数，执行语句alert(i)时，访问的是循环中的变量i。因此，三次弹出均为数值3。</p>

      <p>如果希望实现分别弹出数字0、1、2，需要将代码修改如下：</p>

      <p>
        for(var i=0;i<3;i++){ <br/>
        (function(n){ <br/>
        setTimeout(function(){ <br/>
        alert(n) <br/>
        },3000); <br/>
        })(i); <br/>
        }
      </p>

      <p>
        修改后的代码，使用匿名函数封装一次性定时器的代码，并在调用匿名函数时，将变量i的值作为参数传入。每次循环中，调用一次匿名函数，则启动一个定时器对象，将相应的数字传入。3s后执行函数时，不再访问循环中的局部变量i,则会依次弹出0、1、2</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">35、简述JavaScript中创建自定义对象的方式</h3>
    </div>
    <div class="panel-body">
      <p>自定义对象(user-defined object)指由用户创建的对象，兼容性问题需要由编写者注意。创建自定义对象的方式有：</p>
      <ul>
        <li>1、对象直接量</li>
        <li>2、new Object()</li>
        <li>3、function对象模版</li>
        <li>4、Object.create()</li>
      </ul>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">36、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <p>
        var p = new User("mary"); <br/>
        alert(p.name);//弹出mary <br/>
        p.introduce();//弹出i am mary
      </p>

      <p>为使上段代码正确运行，请定义对象User</p>

      <h3>参考答案：</h3>

      <p>需要使用function模版创建对象User，代码如下：</p>

      <p>
        function User(name){ <br/>
        this.name = name; <br/>
        this.introduce = function(){ <br/>
        alert("i am"+this.name); <br/>
        }; <br/>
        }
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">37、javaScript中，this关键字的作用是什么？</h3>
    </div>
    <div class="panel-body">
      <p>笼统的说，关键字this指向当前对象。比如，顶级代码中的this指向全局对象；在指定元素事件的时候，this指向当前发生事件的元素对象。</p>

      <p>对于嵌套函数，如果嵌套函数作为方法被调用，其this指向调用它的对象；如果作为函数调用，this是全局对象或者为undefined(严格模式下)。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">38、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js22.png" alt=""/>

      <p>请描述上述代码的运行结果。</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码在浏览器中运行后，第一行的输出结果类似于：Object{m:function},表示this关键字指向调用它的当前对象；第二行的输出结果为Window，表示this关键字指向全局变量。
      </p>

      <p>
        这是因为，调用对象o的方法m，在该方法中直接使用this关键字，则指向调用它的对象；然后运行嵌套函数f时，this指向全局对象，在浏览器中运行时，全局对象为Window对象。需要注意的是，如果使用严格模式，则第二行会输出undefined。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">39、查看如下JavaScript代码</h3>
    </div>
    <div class="panel-body">
      <img src="img/js23.png" alt=""/>

      <p>上述代码运行后，输出结果为？</p>

      <h3>参考答案：</h3>

      <p>上述代码运行后，先输出20。这是因为调用对象foo的bar方法时，this关键字指向调动它的对象，即foo，因此，输出该对象中所定义的属性值。<br/>
        第二行将输出10.这是属于函数调用，此时，非严格模式下this指代全局对象window，因此a的值为10。
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">40、简述你对JavaScript中原型的理解</h3>
    </div>
    <div class="panel-body">
      <p>在JavaScript中，函数本身就是一个包含了方法和属性的对象。每个函数中都有一个prototype属性，该属性所存储的就是原型对象。</p>

      <p>原型对象用来保存共享属性和方法，可以通过原型来实现为对象扩展属性，实现继承。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">41、查看如下JavaScript代码</h3>
    </div>
    <div class="panel-body">
      <img src="img/js24.png" alt=""/>

      <p>上述代码运行后，输出结果是？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        第一行输出为：undefined：3500：undefined <br/>
        第二行输出为：john:5500:undefined
      </p>

      <p>JavaScript中，每个函数都有一个prototype属性，该属性引用着该函数的原型对象，原型对象中包含着当前函数所有实例共享的方法和属性。</p>

      <p>使用函数prototype属性可以向函数的原型对象添加或删除属性和方法，并且这些属性和方法时这一类对象所共享的。</p>

      <p>可以使用delete关键字删除对象的属性，包括自有属性和原型属性。</p>

      <p></p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">42、简要描述JavaScript中的自有属性和原型属性。</h3>
    </div>
    <div class="panel-body">
      <p>自有属性是指，通过对象的引用添加的属性，此时，其它对象可能无此属性。对应自有属性，是各个对象所持有的、彼此独立的属性。比如：</p>

      <p>emp1.job = 'Coder';</p>

      <p>原型属性是指从原型对象中继承来的属性，一旦原型对象中属性值改变，所有继承自该原型的对象属性均改变。比如：</p>

      <p>Emp.prototype.dept = '研发部';</p>

      <p>当需要检测对象的自有属性时，可以使用hasOwnProperty()方法。另，还可以使用in操作检测对象及其原型链中是否具备指定属性。</p>

      <p>需要注意的是，在检测对象属性时，先检测自有属性，再检测原型属性。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">43、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js25.png" alt=""/>

      <p>上述代码运行后，输出结果是？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        输出结果分别为：true、true、true、false和true
      </p>

      <p>
        因为在构造函数中定义了属性name，因此变量hero拥有自有属性name。因此在对hero用in操作符检测name属性时，先检测name属性为自有属性还是原型属性，则输出true；使用hasOwnProperty()进行判断也是输出true。</p>

      <p>使用函数的prototype向函数的原型添加属性时，添加的属性age为原型属性。因此，下面代码：</p>

      <p>
        console.log('age',in hero); <br/>
        console.log(hero.hasOwnProperty('age'));
      </p>

      <p>使用in操作符判断时，先判断是否为自有属性，如果没有，则在原型链中查找属性age，因此第一行输出true；但是age并非自有属性，所以第二行输出false。</p>

      <p>此时，再添加代码：</p>

      <p>hero.age = 30;</p>

      <p>这是为hero定义了同名的自有属性age，其值为30。因此，此时再检测hero对象是否自有属性age时，将输出true</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">44、简要描述里对原型链的理解</h3>
    </div>
    <div class="panel-body">
      <p>每个函数中都有prototype属性，该函数被new操作符用于创建对象。将一个函数的prototype属性指向某个对象，由此形成了一条链，称之为原型链。</p>

      <p>可以使用isPrototypeOf()方法判定一个prototype对象是否存在于另一个对象的原型链中。如果是，返回true，否则返回false。</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">45、简要描述JavaScript中的继承</h3>
    </div>
    <div class="panel-body">
      <p>在JavaScript中，继承都是源于原型，有多种实现方式。比如：</p>
      <ul>
        <li>
          1、修改构造函数的原型，为该构造函数创建的对象指定统一的父级对象。代码如下：
          <p>B.prototype = new A();</p>
        </li>
        <li>
          2、只继承于原型(尽可能地将可重用的属性和方法添加到原型中),代码如下:
          <p>B.prototype = A.prototype;</p>
        </li>
        <li>
          3、单独修改一个对象的原型，而不影响其它对象的原型。代码如下：
          <p>
            var b1 = new B(); <br/>
            Object.setPrototypeOf(b1,new A());
          </p>
        </li>
        <li>
          4、修改构造函数，这件影响使用该构造函数创建的所有对象。代码如下：
          <p>
            funtion B(){ <br/>
            Object.setPrototypeOf(this,new A());<br/>
            }
          </p>
        </li>
      </ul>
      <p></p>

      <p></p>

      <p></p>

      <p></p>

      <p></p>

    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">46、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js26.png" alt=""/>

      <p>上述代码运行后，输出结果是？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行后，首先输出unknown；然后输出Caesar；最后输出undefined。
      </p>

      <p>
        查找对象属性时，先查找自有属性，因此，第一次输出的是hero的自有属性name的值，该属性的值从构造函数中继承而来，即为“unknown”；删除hero的自有属性后，在试图输出name属性时，则查找其原型链中的属性name的值并输出，即为“Caesar”;继续删除hero的原型属性后，则输出“undefined”。
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">47、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js27.png" alt=""/>

      <p>上述代码运行后，输出结果是？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行后，首先输出[object Object];然后输出b。
      </p>

      <p>这是因为，虽然修改了B的原型，但是，只影响修改之后的对象。因此，对象b1依然使用默认的从Object继承而来的toString()，因此输出对象的类型和名称。</p>

      <p>对象b2是修改了B的原型之后创建的，因此将使用A中所定义的toString()方法，将输出字符“b”</p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">48、简要描述call和apply的区别？</h3>
    </div>
    <div class="panel-body">
      <p>call()和apply()都用于间接调用函数。</p>

      <p>call()方法用于调用一个对象的一个方法，并以另一个对象替换当前对象。即，任何函数可以作为任何对象的方法来调用，哪怕这个函数并非那个对象的方法。语法如：</p>

      <p>
        call([thisObj[,arg1[,arg2[,...[,argN]]]]])
      </p>

      <p>其中，第一个参数thisObj要调用函数的上下文，即将被用作当前对象的对象。其它参数为可选参数，表示将被传递方法参数序列。</p>

      <p>apply()和call()在作用上是相同的，但两者在参数上有区别的。它俩的第一个参数相同，不同的是第二个参数。对于apply()，第二个参数是一个参数数组，也就是将多个参数组合成为一个数组传入。如：</p>

      <p>
        func.call(func1,var1,var2,var3); <br/>
        func.apply(func1,[var1,var2,var3]);
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">49、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js28.png" alt=""/>

      <p>上述代码运行后，输出结果为？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行后，输出My name is b
      </p>

      <p>
        代码a1.introduce.call(b1);表示对于对象b1调用a1的introduce()方法。
      </p>
    </div>
  </div>
  <div class="panel panel-success">
    <div class="panel-heading ">
      <h3 class="panel-title">50、查看如下JavaScript代码：</h3>
    </div>
    <div class="panel-body">
      <img src="img/js29.png" alt=""/>

      <p>上述代码运行后，输出结果是？</p>

      <h3>参考答案：</h3>

      <p class="shadow">
        上述代码运行后，先弹出显示undefined，再弹出显示2。
      </p>

      <p>
        第一行代码运行后，变量a和b都指向对象{n:1}，第二行代码运行，先为对象{n:1}添加新属性x，其值为{n:2}。此时，对象{n:1}形如{n:1,x:{n:2}}。然后创建新对象{n:2},并将变量a指向这个新对象，而变量b依然指向原有对象。
      </p>

      <p>因此，a.x将输出undefined，因此此时新对象中只有属性n没有属性x；b.x.n将表示向原有对象的中的新属性，因此输出2。</p>
    </div>
  </div>
</div>
<script type="text/javascript" src="js/jquery-1.11.3.js"></script>
<script type="text/javascript" src="js/bootstrap.js"></script>
</body>
</html>